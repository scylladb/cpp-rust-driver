#![allow(clippy::missing_safety_doc)]

use crate::logging::Logger;
use crate::logging::stderr_log_callback;
use std::sync::LazyLock;
use std::sync::RwLock;
use tokio::runtime::Runtime;

#[macro_use]
mod binding;
pub mod api;
// pub, because doctests defined in `argconv` module need to access it.
pub mod argconv;
pub(crate) mod batch;
pub(crate) mod cass_error;
pub(crate) mod cass_types;
pub(crate) mod cluster;
pub(crate) mod collection;
pub(crate) mod config_value;
pub(crate) mod date_time;
pub(crate) mod exec_profile;
pub(crate) mod execution_error;
pub(crate) mod future;
pub(crate) mod inet;
#[cfg(cpp_integration_testing)]
pub(crate) mod integration_testing;
pub(crate) mod iterator;
mod load_balancing;
mod logging;
pub(crate) mod metadata;
pub(crate) mod misc;
pub(crate) mod prepared;
pub(crate) mod query_result;
pub(crate) mod retry_policy;
#[cfg(test)]
mod ser_de_tests;
pub(crate) mod session;
pub(crate) mod ssl;
pub(crate) mod statement;
#[cfg(test)]
pub(crate) mod testing;
pub(crate) mod timestamp_generator;
pub(crate) mod tuple;
pub(crate) mod user_type;
pub(crate) mod uuid;
pub(crate) mod value;

/// Includes a file generated by bindgen called `filename`.
macro_rules! include_bindgen_generated {
    ($filename:expr) => {
        include!(concat!(env!("OUT_DIR"), '/', $filename));
    };
}

/// All numeric types are defined here.
pub mod types {
    #![allow(non_camel_case_types)]
    // for `cass_false` and `cass_true` globals.
    #![allow(non_upper_case_globals)]
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    // Definition for size_t (and possibly other types in the future)
    include_bindgen_generated!("basic_types.rs");
}

/// CassError, CassErrorSource, CassWriteType
pub(crate) mod cass_error_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_error_types.rs");
}

/// CassValueType
pub(crate) mod cass_data_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_data_types.rs");
}

/// CassConsistency
pub(crate) mod cass_consistency_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_consistency_types.rs");
}

/// CassBatchType
pub(crate) mod cass_batch_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_batch_types.rs");
}

/// CassCompressionType
pub(crate) mod cass_compression_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_compression_types.rs");
}

/// CassCollectionType
pub(crate) mod cass_collection_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_collection_types.rs");
}

/// CassInet
pub(crate) mod cass_inet_types {
    #![allow(unused)]
    #![allow(non_camel_case_types, non_snake_case)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_inet_types.rs");
}

/// CassLogLevel, CassLogMessage
pub(crate) mod cass_log_types {
    #![allow(unused)]
    #![allow(non_camel_case_types, non_snake_case)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_log_types.rs");
}

/// CassColumnType
pub(crate) mod cass_column_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_column_type.rs");
}

/// CassUuid
pub(crate) mod cass_uuid_types {
    #![allow(unused)]
    #![allow(non_camel_case_types, non_snake_case)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_uuid_types.rs");
}

/// CassIteratorType
pub(crate) mod cass_iterator_types {
    #![allow(unused)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_iterator_types.rs");
}

/// CassMetrics
pub(crate) mod cass_metrics_types {
    #![allow(unused)]
    #![allow(non_camel_case_types, non_snake_case)]
    #![allow(unreachable_pub, unnameable_types)]

    include_bindgen_generated!("cppdriver_metrics_types.rs");
}

pub(crate) static RUNTIME: LazyLock<Runtime> = LazyLock::new(|| Runtime::new().unwrap());
pub(crate) static LOGGER: LazyLock<RwLock<Logger>> = LazyLock::new(|| {
    RwLock::new(Logger {
        cb: Some(stderr_log_callback),
        data: std::ptr::null_mut(),
    })
});

// To send a Rust object to C:

// #[unsafe(no_mangle)]
// pub extern "C" fn create_foo() -> *mut Foo {
//     BoxFFI::into_raw(Box::new(Foo))
// }

// To borrow (and not free) from C:

// #[unsafe(no_mangle)]
// pub unsafe extern "C" fn do(foo: *mut Foo) -> *mut Foo {
//     let foo = argconv::ptr_to_ref(foo);
// }

// To take over/destroy Rust object previously given to C:

// #[unsafe(no_mangle)]
// pub unsafe extern "C" fn free_foo(foo: *mut Foo) {
//     // Take the ownership of the value and it will be automatically dropped
//     argconv::ptr_to_opt_box(foo);
// }
